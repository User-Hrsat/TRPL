上一页：[变量和可变性](变量和可变性.md)

> 字符串格式化？

### 标量类型
> 标量（scalar）类型代表一个单独的值
- Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型

#### 整型

- **Rust 中的整型**

<table>
    <thead>
        <tr>
            <th>长度</th>
            <th>有符号</th>
            <th>无符号</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>8-bit</td>
            <td><code>i8</code></td>
            <td><code>u8</code></td>
        </tr>
        <tr>
            <td>16-bit</td>
            <td><code>i16</code></td>
            <td><code>u16</code></td>
        </tr>
        <tr>
            <td>32-bit</td>
            <td><code>i32</code></td>
            <td><code>u32</code></td>
        </tr>
        <tr>
            <td>64-bit</td>
            <td><code>i64</code></td>
            <td><code>u64</code></td>
        </tr>
        <tr>
            <td>128-bit</td>
            <td><code>i128</code></td>
            <td><code>u128</code></td>
        </tr>
        <tr>
            <td>arch</td>
            <td><code>isize</code></td>
            <td><code>usize</code></td>
        </tr>
    </tbody>
</table>

**有符号数以补码形式（[two’s complement representation](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)） 存储**

- **Rust 中的整型字面值**

<table>
    <thead>
        <tr>
            <th>数字字面值</th>
            <th>例子</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Decimal (十进制)</td>
            <td><code>98_222</code></td>
        </tr>
        <tr>
            <td>Hex (十六进制)</td>
            <td><code>0xff</code></td>
        </tr>
        <tr>
            <td>Octal (八进制)</td>
            <td><code>0o77</code></td>
        </tr>
        <tr>
            <td>Binary (二进制)</td>
            <td><code>0b1111_0000</code></td>
        </tr>
        <tr>
            <td>Byte (单字节字符)(仅限于<code>u8</code>)</td>
            <td><code>b'A'</code></td>
        </tr>
    </tbody>
</table>

Rust 中数字类型默认是 `i32`
`isize` 或 `usize` 主要作为某些集合的索引

> 整型溢出
> 比方说有一个 `u8` ，它可以存放从零到 `255` 的值。那么当你将其修改为 `256` 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），这会导致以下两种行为之一的发生。当在 debug 模式编译时，Rust 检查这类问题并使程序 `panic`，这个术语被 Rust 用来表明程序因错误而退出。第九章 “panic! 与不可恢复的错误” 部分会详细介绍` panic`。
> 
> 使用 `--release` flag 在 release 模式中构建时，Rust 不会检测会导致 panic 的整型溢出。相反发生整型溢出时，Rust 会进行一种被称为二进制补码 wrapping（two’s complement wrapping）的操作。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 `256` 变成 `0`，值 `257` 变成 `1`，依此类推。程序不会 `panic`，不过变量可能也不会是你所期望的值。依赖整型溢出 `wrapping` 的行为被认为是一种错误。
> 
> 为了显式地处理溢出的可能性，可以使用这几类标准库提供的原始数字类型方法：
> 
>   - 所有模式下都可以使用 `wrapping_*` 方法进行 `wrapping`，如 `wrapping_add`
>   - 如果 `checked_*` 方法出现溢出，则返回 `None` 值
>   - 用 `overflowing_*` 方法返回值和一个布尔值，表示是否出现溢出
>   - 用 `saturating_*` 方法在值的最小值或最大值处进行饱和处理

#### 浮点型
> Rust 的浮点数类型是 `f32` 和 `f64`，都是有符号的

浮点数采用 [`IEEE-754🔗`](https://zh.wikipedia.org/wiki/IEEE_754) 标准表示
`f32` 是单精度浮点数，`f64` 是双精度浮点数

### 复合类型
> 复合类型（Compound types）
- Rust 有两个原生的复合类型：元组（tuple）和数组（array）